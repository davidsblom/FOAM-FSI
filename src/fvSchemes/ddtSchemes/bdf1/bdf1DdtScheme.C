
#include "bdf1DdtScheme.H"
#include "surfaceInterpolate.H"
#include "fvcDiv.H"
#include "fvMatrices.H"
#include "slipFvPatchFields.H"
#include "symmetryFvPatchFields.H"
#include "basicSymmetryFvPatchFields.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

namespace Foam
{
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    namespace fv
    {
        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

        template<class Type>
        tmp<GeometricField<Type, fvPatchField, volMesh> >
        bdf1DdtScheme<Type>::fvcDdt
            ( const dimensioned<Type> & dt )
        {
            dimensionedScalar rDeltaT = 1.0 / mesh().time().deltaT();

            IOobject ddtIOobject
            (
                "ddt(" + dt.name() + ')',
                mesh().time().timeName(),
                mesh()
            );

            if ( mesh().moving() )
            {
                tmp<GeometricField<Type, fvPatchField, volMesh> > tdtdt
                (
                    new GeometricField<Type, fvPatchField, volMesh>
                    (
                        ddtIOobject,
                        mesh(),
                        dimensioned<Type>
                        (
                            "0",
                            dt.dimensions() / dimTime,
                            pTraits<Type>::zero
                        )
                    )
                );

                tdtdt().internalField() =
                    rDeltaT.value() * dt.value() * ( 1.0 - mesh().V0() / mesh().V() );

                return tdtdt;
            }
            else
            {
                return tmp<GeometricField<Type, fvPatchField, volMesh> >
                       (
                    new GeometricField<Type, fvPatchField, volMesh>
                    (
                        ddtIOobject,
                        mesh(),
                        dimensioned<Type>
                        (
                            "0",
                            dt.dimensions() / dimTime,
                            pTraits<Type>::zero
                        ),
                        calculatedFvPatchField<Type>::typeName
                    )
                       );
            }
        }

        template<class Type>
        tmp<GeometricField<Type, fvPatchField, volMesh> >
        bdf1DdtScheme<Type>::fvcDdt
            ( const GeometricField<Type, fvPatchField, volMesh> & vf )
        {
            dimensionedScalar rDeltaT = 1.0 / mesh().time().deltaT();

            IOobject ddtIOobject
            (
                "ddt(" + vf.name() + ')',
                mesh().time().timeName(),
                mesh()
            );

            if ( mesh().moving() )
            {
                return tmp<GeometricField<Type, fvPatchField, volMesh> >
                       (
                    new GeometricField<Type, fvPatchField, volMesh>
                    (
                        ddtIOobject,
                        mesh(),
                        rDeltaT.dimensions() * vf.dimensions(),
                        rDeltaT.value() *
                        (
                            vf.internalField()
                            - vf.oldTime().internalField() * mesh().V0() / mesh().V()
                        ),
                        rDeltaT.value() *
                        (
                            vf.boundaryField() - vf.oldTime().boundaryField()
                        )
                    )
                       );
            }
            else
            {
                return tmp<GeometricField<Type, fvPatchField, volMesh> >
                       (
                    new GeometricField<Type, fvPatchField, volMesh>
                    (
                        ddtIOobject,
                        rDeltaT * ( vf - vf.oldTime() )
                    )
                       );
            }
        }

        template<class Type>
        tmp<GeometricField<Type, fvPatchField, volMesh> >
        bdf1DdtScheme<Type>::fvcDdt
        (
            const dimensionedScalar & rho,
            const GeometricField<Type, fvPatchField, volMesh> & vf
        )
        {
            dimensionedScalar rDeltaT = 1.0 / mesh().time().deltaT();

            IOobject ddtIOobject
            (
                "ddt(" + rho.name() + ',' + vf.name() + ')',
                mesh().time().timeName(),
                mesh()
            );

            if ( mesh().moving() )
            {
                return tmp<GeometricField<Type, fvPatchField, volMesh> >
                       (
                    new GeometricField<Type, fvPatchField, volMesh>
                    (
                        ddtIOobject,
                        mesh(),
                        rDeltaT.dimensions() * rho.dimensions() * vf.dimensions(),
                        rDeltaT.value() * rho.value() *
                        (
                            vf.internalField()
                            - vf.oldTime().internalField() * mesh().V0() / mesh().V()
                        ),
                        rDeltaT.value() * rho.value() *
                        (
                            vf.boundaryField() - vf.oldTime().boundaryField()
                        )
                    )
                       );
            }
            else
            {
                return tmp<GeometricField<Type, fvPatchField, volMesh> >
                       (
                    new GeometricField<Type, fvPatchField, volMesh>
                    (
                        ddtIOobject,
                        rDeltaT * rho * ( vf - vf.oldTime() )
                    )
                       );
            }
        }

        template<class Type>
        tmp<GeometricField<Type, fvPatchField, volMesh> >
        bdf1DdtScheme<Type>::fvcDdt
        (
            const volScalarField & rho,
            const GeometricField<Type, fvPatchField, volMesh> & vf
        )
        {
            dimensionedScalar rDeltaT = 1.0 / mesh().time().deltaT();

            IOobject ddtIOobject
            (
                "ddt(" + rho.name() + ',' + vf.name() + ')',
                mesh().time().timeName(),
                mesh()
            );

            if ( mesh().moving() )
            {
                return tmp<GeometricField<Type, fvPatchField, volMesh> >
                       (
                    new GeometricField<Type, fvPatchField, volMesh>
                    (
                        ddtIOobject,
                        mesh(),
                        rDeltaT.dimensions() * rho.dimensions() * vf.dimensions(),
                        rDeltaT.value() *
                        (
                            rho.internalField() * vf.internalField()
                            - rho.oldTime().internalField()
                            * vf.oldTime().internalField() * mesh().V0() / mesh().V()
                        ),
                        rDeltaT.value() *
                        (
                            rho.boundaryField() * vf.boundaryField()
                            - rho.oldTime().boundaryField()
                            * vf.oldTime().boundaryField()
                        )
                    )
                       );
            }
            else
            {
                return tmp<GeometricField<Type, fvPatchField, volMesh> >
                       (
                    new GeometricField<Type, fvPatchField, volMesh>
                    (
                        ddtIOobject,
                        rDeltaT * ( rho * vf - rho.oldTime() * vf.oldTime() )
                    )
                       );
            }
        }

        template<class Type>
        tmp<fvMatrix<Type> >
        bdf1DdtScheme<Type>::fvmDdt
            ( GeometricField<Type, fvPatchField, volMesh> & vf )
        {
            tmp<fvMatrix<Type> > tfvm
            (
                new fvMatrix<Type>
                (
                    vf,
                    vf.dimensions() * dimVol / dimTime
                )
            );

            fvMatrix<Type> & fvm = tfvm();

            scalar rDeltaT = 1.0 / mesh().time().deltaT().value();

            fvm.diag() = rDeltaT * mesh().V();

            if ( mesh().moving() )
            {
                fvm.source() = rDeltaT * vf.oldTime().internalField() * mesh().V0();
            }
            else
            {
                fvm.source() = rDeltaT * vf.oldTime().internalField() * mesh().V();
            }

            return tfvm;
        }

        template<class Type>
        tmp<fvMatrix<Type> >
        bdf1DdtScheme<Type>::fvmDdt
        (
            const dimensionedScalar & rho,
            GeometricField<Type, fvPatchField, volMesh> & vf
        )
        {
            tmp<fvMatrix<Type> > tfvm
            (
                new fvMatrix<Type>
                (
                    vf,
                    rho.dimensions() * vf.dimensions() * dimVol / dimTime
                )
            );
            fvMatrix<Type> & fvm = tfvm();

            scalar rDeltaT = 1.0 / mesh().time().deltaT().value();

            fvm.diag() = rDeltaT * rho.value() * mesh().V();

            if ( mesh().moving() )
            {
                fvm.source() = rDeltaT
                    * rho.value() * vf.oldTime().internalField() * mesh().V0();
            }
            else
            {
                fvm.source() = rDeltaT
                    * rho.value() * vf.oldTime().internalField() * mesh().V();
            }

            return tfvm;
        }

        template<class Type>
        tmp<fvMatrix<Type> >
        bdf1DdtScheme<Type>::fvmDdt
        (
            const volScalarField & rho,
            GeometricField<Type, fvPatchField, volMesh> & vf
        )
        {
            tmp<fvMatrix<Type> > tfvm
            (
                new fvMatrix<Type>
                (
                    vf,
                    rho.dimensions() * vf.dimensions() * dimVol / dimTime
                )
            );
            fvMatrix<Type> & fvm = tfvm();

            scalar rDeltaT = 1.0 / mesh().time().deltaT().value();

            fvm.diag() = rDeltaT * rho.internalField() * mesh().V();

            if ( mesh().moving() )
            {
                fvm.source() = rDeltaT
                    * rho.oldTime().internalField()
                    * vf.oldTime().internalField() * mesh().V0();
            }
            else
            {
                fvm.source() = rDeltaT
                    * rho.oldTime().internalField()
                    * vf.oldTime().internalField() * mesh().V();
            }

            return tfvm;
        }

        template<class Type>
        tmp<typename bdf1DdtScheme<Type>::fluxFieldType>
        bdf1DdtScheme<Type>::fvcDdtPhiCorr
        (
            const volScalarField & rA,
            const GeometricField<Type, fvPatchField, volMesh> & U,
            const fluxFieldType & phiAbs
        )
        {
            dimensionedScalar rDeltaT = 1.0 / mesh().time().deltaT();

            IOobject ddtIOobject
            (
                "ddtPhiCorr(" + rA.name() + ',' + U.name() + ',' + phiAbs.name() + ')',
                mesh().time().timeName(),
                mesh()
            );

            // === Set boundaries correct of U === //
            surfaceScalarField ddtPhiCoeff
            (
                IOobject
                (
                    "ddtPhiCoeff",
                    mesh().time().timeName(),
                    mesh(),
                    IOobject::NO_READ,
                    IOobject::NO_WRITE
                ),
                mesh(),
                dimensioned<scalar>( "1", dimless, 1.0 )
            );

            forAll( U.boundaryField(), patchI )
            {
                ddtPhiCoeff.boundaryField()[patchI] = 0.0;
            }

            // tmp<fluxFieldType> phiCorr =
            // phiAbs.oldTime() - (fvc::interpolate(U.oldTime()) & mesh().Sf());
            tmp<fluxFieldType> phiCorr =
                phiAbs.oldTime() - ( fvc::interpolate( U.oldTime() ) & mesh().Sf() ); // TEMP: Everything should be old including Sf (Paper tukovic about Rhie-Chow interpolation)

            // === make sure fvc::interpolate is performed on 1.0/rA seperately === //
            return tmp<fluxFieldType>
                   (
                new fluxFieldType
                (
                    ddtIOobject,
                    rDeltaT * ddtPhiCoeff // fvcDdtPhiCoeff(U.oldTime(), phiAbs.oldTime(), phiCorr())
                    * 1.0 / fvc::interpolate( 1.0 / rA ) * phiCorr
                )
                   );
        }

        template<>
        tmp<surfaceScalarField> bdf1DdtScheme<vector>::fvcDdtPhiCorr
        (
            const volScalarField & rA,
            const GeometricField<vector, fvPatchField, volMesh> & U,
            const surfaceScalarField & phi
        )
        {
            // Info << "Consistent EulerDdtPhiCorr" << endl;

            dimensionedScalar rDeltaT = 1.0 / mesh().time().deltaT();

            IOobject ddtIOobject
            (
                "ddtPhiCorr(" + rA.name() + ',' + U.name() + ',' + phi.name() + ')',
                mesh().time().timeName(),
                mesh()
            );

            // Set coefficient for excluding certain boundaries from ddtPhiCorr
            surfaceScalarField ddtPhiCoeff
            (
                IOobject
                (
                    "ddtPhiCoeff",
                    mesh().time().timeName(),
                    mesh(),
                    IOobject::NO_READ,
                    IOobject::NO_WRITE
                ),
                mesh(),
                dimensioned<scalar>( "1", dimless, 1.0 )
            );

            // Set coefficients at boundary which have fixedValues to 0
            forAll( U.boundaryField(), patchI )
            {
                if
                (
                    U.boundaryField()[patchI].fixesValue()
                    || isA<symmetryFvPatchVectorField>( U.boundaryField()[patchI] )
                    || isA<basicSymmetryFvPatchVectorField>( U.boundaryField()[patchI] )
                    || isA<slipFvPatchVectorField>( U.boundaryField()[patchI] )
                )
                {
                    ddtPhiCoeff.boundaryField()[patchI] = 0.0;
                }
            }

            // If mesh is moving
            if ( mesh().moving() )
            {
                // Set volume ratio of oldV over V
                volScalarField V0oV
                (
                    IOobject
                    (
                        "V0oV",
                        mesh().time().timeName(),
                        mesh(),
                        IOobject::NO_READ,
                        IOobject::NO_WRITE
                    ),
                    mesh(),
                    dimless,
                    zeroGradientFvPatchScalarField::typeName
                );

                V0oV.internalField() = mesh().V0() / mesh().V();
                V0oV.correctBoundaryConditions();

                // Dimension check
                if ( U.dimensions() == dimVelocity && phi.dimensions() == dimVelocity * dimArea )
                {
                    // Get Uf with old times recorded
                    const surfaceVectorField & Uf = mesh().objectRegistry::lookupObject<surfaceVectorField>( "Uf" );

                    // Construct parts of H which need to be subtracted
                    tmp<surfaceVectorField> UV0oV = -fvc::interpolate( V0oV * U.oldTime() ); // term coming from H/A

                    // Create return variable
                    return tmp<surfaceScalarField>
                           (
                        new surfaceScalarField
                        (
                            ddtIOobject,
                            rDeltaT * ddtPhiCoeff
                            * (
                                ( UV0oV + fvc::interpolate( V0oV ) * ( Uf.oldTime() ) ) & mesh().Sf()
                                ) / fvc::interpolate( 1.0 / rA )
                        )
                           );
                }
                else
                {
                    FatalErrorIn
                    (
                        "EulerDdtScheme<vector>::fvcDdtPhiCorr"
                    ) << "dimensions of phi are not correct"
                      << abort( FatalError );

                    return fluxFieldType::null();
                }
            }
            else
            {
                // If not moving simplify calculations
                if ( U.dimensions() == dimVelocity && phi.dimensions() == dimVelocity * dimArea )
                {
                    // Set interpolated old velocity
                    tmp<surfaceScalarField> phi0 = phi.oldTime() - ( fvc::interpolate( U.oldTime() ) & mesh().Sf() );

                    // Create return variable
                    return tmp<fluxFieldType>
                           (
                        new fluxFieldType
                        (
                            ddtIOobject,
                            rDeltaT * ddtPhiCoeff
                            * (
                                phi0
                                )
                            / fvc::interpolate( 1.0 / rA )
                        )
                           );
                }
                else
                {
                    FatalErrorIn
                    (
                        "EulerDdtScheme<vector>::fvcDdtPhiCorr"
                    ) << "dimensions of phi are not correct"
                      << abort( FatalError );

                    return fluxFieldType::null();
                }
            }
        }

        template<class Type>
        tmp<typename bdf1DdtScheme<Type>::fluxFieldType>
        bdf1DdtScheme<Type>::fvcDdtPhiCorr
        (
            const volScalarField & rA,
            const volScalarField & rho,
            const GeometricField<Type, fvPatchField, volMesh> & U,
            const fluxFieldType & phiAbs
        )
        {
            dimensionedScalar rDeltaT = 1.0 / mesh().time().deltaT();

            IOobject ddtIOobject
            (
                "ddtPhiCorr("
                + rA.name() + ','
                + rho.name() + ','
                + U.name() + ','
                + phiAbs.name() + ')',
                mesh().time().timeName(),
                mesh()
            );

            if
            (
                U.dimensions() == dimVelocity
                && phiAbs.dimensions() == dimVelocity * dimArea
            )
            {
                return tmp<fluxFieldType>
                       (
                    new fluxFieldType
                    (
                        ddtIOobject,
                        rDeltaT
                        * this->fvcDdtPhiCoeff( U.oldTime(), phiAbs.oldTime() )
                        * (
                            fvc::interpolate( rA * rho.oldTime() ) * phiAbs.oldTime()
                            - ( fvc::interpolate( rA * rho.oldTime() * U.oldTime() )
                            & mesh().Sf() )
                            )
                    )
                       );
            }
            else
            if
            (
                U.dimensions() == dimVelocity
                && phiAbs.dimensions() == rho.dimensions() * dimVelocity * dimArea
            )
            {
                return tmp<fluxFieldType>
                       (
                    new fluxFieldType
                    (
                        ddtIOobject,
                        rDeltaT
                        * this->fvcDdtPhiCoeff
                        (
                            U.oldTime(),
                            phiAbs.oldTime() / fvc::interpolate( rho.oldTime() )
                        )
                        * (
                            fvc::interpolate( rA * rho.oldTime() )
                            * phiAbs.oldTime() / fvc::interpolate( rho.oldTime() )
                            - (
                                fvc::interpolate
                                (
                                    rA * rho.oldTime() * U.oldTime()
                                ) & mesh().Sf()
                                )
                            )
                    )
                       );
            }
            else
            if
            (
                U.dimensions() == rho.dimensions() * dimVelocity
                && phiAbs.dimensions() == rho.dimensions() * dimVelocity * dimArea
            )
            {
                return tmp<fluxFieldType>
                       (
                    new fluxFieldType
                    (
                        ddtIOobject,
                        rDeltaT
                        * this->fvcDdtPhiCoeff( rho.oldTime(), U.oldTime(), phiAbs.oldTime() )
                        * (
                            fvc::interpolate( rA ) * phiAbs.oldTime()
                            - ( fvc::interpolate( rA * U.oldTime() ) & mesh().Sf() )
                            )
                    )
                       );
            }
            else
            {
                FatalErrorIn
                (
                    "bdf1DdtScheme<Type>::fvcDdtPhiCorr"
                ) << "dimensions of phiAbs are not correct"
                  << abort( FatalError );

                return fluxFieldType::null();
            }
        }

        template<class Type>
        tmp<surfaceScalarField> bdf1DdtScheme<Type>::meshPhi
            ( const GeometricField<Type, fvPatchField, volMesh> & )
        {
            return mesh().phi();
        }

        // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    } // End namespace fv

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
} // End namespace Foam

// ************************************************************************* //
