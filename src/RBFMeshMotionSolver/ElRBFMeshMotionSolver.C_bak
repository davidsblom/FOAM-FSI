
/*
 * Author
 *   David Blom, TU Delft. All rights reserved.
 */

#include <mxx/sort.hpp>
#include "ElRBFMeshMotionSolver.H"
#include "TPSFunction.H"
#include <cassert>

using namespace Foam;

defineTypeNameAndDebug( ElRBFMeshMotionSolver, 0 );

addToRunTimeSelectionTable
(
    motionSolver,
    ElRBFMeshMotionSolver,
    dictionary
);

ElRBFMeshMotionSolver::ElRBFMeshMotionSolver(
    const Foam::polyMesh & mesh,
    Foam::Istream & msData
    )
    :
    motionSolver( mesh ),
    motionCenters( mesh.boundaryMesh().size(), vectorField( 0 ) ),
    newPoints( mesh.points().size(), vector::zero ),
    movingPatchIDs( wordList( lookup( "movingPatches" ) ).size(), 0 ),
    staticPatchIDs( wordList( lookup( "staticPatches" ) ).size(), 0 ),
    rbf( new rbf::ElRBFInterpolation() ),
    twoDCorrector( mesh )
{
    wordList staticPatches( lookup( "staticPatches" ) );
    wordList movingPatches( lookup( "movingPatches" ) );
    assert( staticPatches.size() == staticPatchIDs.size() );
    assert( movingPatches.size() == movingPatchIDs.size() );

    // Find IDs of staticPatches
    forAll( staticPatches, patchI )
    {
        label patchIndex = mesh.boundaryMesh().findPatchID( staticPatches[patchI] );

        assert( patchIndex >= 0 );

        staticPatchIDs[patchI] = patchIndex;
    }

    // Find IDs of movingPatches
    forAll( movingPatches, patchI )
    {
        label patchIndex = mesh.boundaryMesh().findPatchID( movingPatches[patchI] );

        assert( patchIndex >= 0 );

        movingPatchIDs[patchI] = patchIndex;
    }

    // Verify that a patch is not defined as a static and a moving patch

    forAll( staticPatchIDs, staticPatchI )
    {
        // Search the moving patches for static patchI
        forAll( movingPatchIDs, movingPatchI )
        {
            assert( movingPatchIDs[movingPatchI] != staticPatchIDs[staticPatchI] );
        }
    }

    // Initialize zero motion

    forAll( movingPatchIDs, patchId )
    {
        motionCenters[movingPatchIDs[patchId]] = vectorField( mesh.boundaryMesh()[movingPatchIDs[patchId]].meshPoints().size(), Foam::vector::zero );
    }
}

ElRBFMeshMotionSolver::~ElRBFMeshMotionSolver()
{}

tmp<pointField> ElRBFMeshMotionSolver::curPoints() const
{
    // Prepare new points: same as old point
    tmp<pointField> tnewPoints
    (
        new vectorField( mesh().nPoints(), vector::zero )
    );

    pointField & newPoints = tnewPoints();

    newPoints = this->newPoints;

    // Add old point positions
    newPoints += mesh().points();

    return tnewPoints;
}

// As a first step, the motion is defined in the
void ElRBFMeshMotionSolver::setMotion( const Field<vectorField> & motion )
{
    // Input checking

    assert( motion.size() == mesh().boundaryMesh().size() );

    forAll( motion, ipatch )
    {
        const vectorField & mpatch = motion[ipatch];

        if ( mpatch.size() > 0 )
            assert( mpatch.size() == mesh().boundaryMesh()[ipatch].meshPoints().size() );

        // Check whether the size of a moving patch is equal to the number of face centers in the patch
        // First check if patchid is a moving patch
        bool movingPatch = false;
        forAll( movingPatchIDs, movingPatchI )
        {
            if ( movingPatchIDs[movingPatchI] == ipatch )
                movingPatch = true;
        }

        if ( movingPatch )
            assert( mpatch.size() == mesh().boundaryMesh()[ipatch].meshPoints().size() );
    }

    motionCenters = motion;
}

void ElRBFMeshMotionSolver::updateMesh( const mapPolyMesh & )
{
    assert( false );
}

void ElRBFMeshMotionSolver::solve()
{
    if ( not rbf->initialized() )
    {
        assert( boundaryPoints.size() == 0 );

        forAll( staticPatchIDs, patchId )
        {
            const labelList & meshPoints = mesh().boundaryMesh()[staticPatchIDs[patchId]].meshPoints();

            forAll( meshPoints, i )
            {
                if ( twoDCorrector.marker()[meshPoints[i]] != 0 )
                    continue;

                if ( boundaryPoints.find( meshPoints[i] ) != boundaryPoints.end() )
                    continue;

                Vertex vertex;
                vertex.owner = true;
                vertex.moving = false;
                vertex.pointId = meshPoints[i];
                vertex.globalPointId = 0;
                vertex.id = boundaryPoints.size();

                for ( int j = 0; j < mesh().nGeometricD(); j++ )
                    vertex.coord.push_back( mesh().points()[vertex.pointId][j] );

                boundaryPoints[vertex.pointId] = vertex;
            }
        }

        forAll( movingPatchIDs, patchId )
        {
            const labelList & meshPoints = mesh().boundaryMesh()[movingPatchIDs[patchId]].meshPoints();

            forAll( meshPoints, i )
            {
                if ( twoDCorrector.marker()[meshPoints[i]] != 0 )
                    continue;

                if ( boundaryPoints.find( meshPoints[i] ) != boundaryPoints.end() )
                    continue;

                Vertex vertex;
                vertex.owner = true;
                vertex.moving = true;
                vertex.pointId = meshPoints[i];
                vertex.globalPointId = 0;
                vertex.id = boundaryPoints.size();

                for ( int j = 0; j < mesh().nGeometricD(); j++ )
                    vertex.coord.push_back( mesh().points()[vertex.pointId][j] );

                boundaryPoints[vertex.pointId] = vertex;
            }
        }

        if ( Pstream::parRun() )
        {
            IOobject addrHeader
            (
                "pointProcAddressing",
                mesh().facesInstance(),
                mesh().meshSubDir,
                mesh(),
                IOobject::MUST_READ
            );

            assert( addrHeader.headerOk() );
            labelIOList pointProcAddressing( addrHeader );

            assert( pointProcAddressing.size() == mesh().points().size() );

            for ( auto & vertex : boundaryPoints )
            {
                vertex.second.globalPointId = pointProcAddressing[vertex.second.pointId];
            }
        }
        else
        {
            for ( auto & vertex : boundaryPoints )
            {
                vertex.second.globalPointId = vertex.second.pointId;
            }
        }

        typedef std::tuple<int, double, double, double> tuple_type;

        std::vector<tuple_type> data;

        for ( const auto & vertex : boundaryPoints )
        {
            if ( mesh().nGeometricD() == 2 )
                data.push_back( std::make_tuple( vertex.second.globalPointId, vertex.second.coord[0], vertex.second.coord[1], 0 ) );
            else
                data.push_back( std::make_tuple( vertex.second.globalPointId, vertex.second.coord[0], vertex.second.coord[1], vertex.second.coord[2] ) );
        }

        // comparator for sorting
        auto cmp = []( const tuple_type & x, const tuple_type & y ) {
                return std::get<0>( x ) < std::get<0>( y );
            };

        mxx::comm c;
        mxx::sort( data.begin(), data.end(), cmp, c );

        auto cmp_unique = []( const tuple_type & x, const tuple_type & y ) {
                return std::get<0>( x ) == std::get<0>( y );
            };

        auto it = mxx::unique( data.begin(), data.end(), cmp_unique, c );

        data.resize( std::distance( data.begin(), it ) );

        std::vector<size_t> allBoundaryPoints = mxx::allgather( data.size() );
        size_t totalNbBoundaryPoints = 0;

        for ( size_t n : allBoundaryPoints )
            totalNbBoundaryPoints += n;

        std::unique_ptr<El::DistMatrix<double> > positions( new El::DistMatrix<double>() );
        El::Zeros( *positions, totalNbBoundaryPoints, mesh().nGeometricD() );

        positions->Reserve( data.size() * mesh().nGeometricD() );

        size_t localBoundaryOffset = 0;

        for ( int i = 0; i < Pstream::myProcNo(); i++ )
            localBoundaryOffset += allBoundaryPoints[i];

        {
            int i = 0;

            for ( const auto & vertex : data )
            {
                positions->QueueUpdate( localBoundaryOffset + i, 0, std::get<1>( vertex ) );
                positions->QueueUpdate( localBoundaryOffset + i, 1, std::get<2>( vertex ) );

                if ( mesh().nGeometricD() == 3 )
                    positions->QueueUpdate( localBoundaryOffset + i, 2, std::get<3>( vertex ) );

                i++;
            }
        }

        int nbInterpolationPoints = 0;

        forAll( mesh().points(), i )
        {
            if ( twoDCorrector.marker()[i] == 0 )
                nbInterpolationPoints++;
        }

        std::vector<int> allInterpolationPoints = mxx::allgather( nbInterpolationPoints );
        int totalNbInterpolationPoints = 0;

        for ( int n : allInterpolationPoints )
            totalNbInterpolationPoints += n;

        std::unique_ptr<El::DistMatrix<double> > positionsInterpolation( new El::DistMatrix<double> () );
        El::Zeros( *positionsInterpolation, totalNbInterpolationPoints, mesh().nGeometricD() );

        positionsInterpolation->Reserve( nbInterpolationPoints * mesh().nGeometricD() );

        {
            int index = 0;

            size_t localOffset = 0;

            for ( int i = 0; i < Pstream::myProcNo(); i++ )
                localOffset += allInterpolationPoints[i];

            forAll( mesh().points(), i )
            {
                if ( twoDCorrector.marker()[i] != 0 )
                    continue;

                for ( int j = 0; j < mesh().nGeometricD(); j++ )
                {
                    positionsInterpolation->QueueUpdate( localOffset + index, j, mesh().points()[i][j] );
                }

                index++;
            }
        }

        std::unique_ptr<rbf::RBFFunctionInterface> rbfFunction( new rbf::TPSFunction() );
        rbf->compute( std::move( rbfFunction ), std::move( positions ), std::move( positionsInterpolation ) );
    }

    forAll( movingPatchIDs, patchId )
    {
        const labelList & meshPoints = mesh().boundaryMesh()[movingPatchIDs[patchId]].meshPoints();

        forAll( meshPoints, i )
        {
            int pointId = meshPoints[i];

            if ( boundaryPoints.find( pointId ) != boundaryPoints.end() )
            {
                auto & vertex = boundaryPoints[pointId];

                if ( not vertex.moving )
                {
                    for ( auto & el : vertex.coord )
                        el = 0;
                }
                else
                {
                    int j = 0;

                    for ( auto & el : vertex.coord )
                    {
                        el = motionCenters[movingPatchIDs[patchId]][i][j];
                        j++;
                    }
                }
            }
        }
    }

    typedef std::tuple<int, double, double, double> tuple_type;

    std::vector<tuple_type> data;

    for ( const auto & vertex : boundaryPoints )
    {
        if ( mesh().nGeometricD() == 2 )
            data.push_back( std::make_tuple( vertex.second.globalPointId, vertex.second.coord[0], vertex.second.coord[1], 0 ) );
        else
            data.push_back( std::make_tuple( vertex.second.globalPointId, vertex.second.coord[0], vertex.second.coord[1], vertex.second.coord[2] ) );
    }

    // comparator for sorting
    auto cmp = []( const tuple_type & x, const tuple_type & y ) {
            return std::get<0>( x ) < std::get<0>( y );
        };

    mxx::comm c;
    mxx::sort( data.begin(), data.end(), cmp, c );

    auto cmp_unique = []( const tuple_type & x, const tuple_type & y ) {
            return std::get<0>( x ) == std::get<0>( y );
        };

    auto it = mxx::unique( data.begin(), data.end(), cmp_unique, c );

    data.resize( std::distance( data.begin(), it ) );

    std::vector<size_t> allBoundaryPoints = mxx::allgather( data.size() );
    size_t totalNbBoundaryPoints = 0;

    for ( size_t n : allBoundaryPoints )
        totalNbBoundaryPoints += n;

    std::unique_ptr<El::DistMatrix<double> > values( new El::DistMatrix<double>() );
    El::Zeros( *values, totalNbBoundaryPoints, mesh().nGeometricD() );

    values->Reserve( data.size() * mesh().nGeometricD() );

    size_t localBoundaryOffset = 0;

    for ( int i = 0; i < Pstream::myProcNo(); i++ )
        localBoundaryOffset += allBoundaryPoints[i];

    {
        int i = 0;

        for ( const auto & vertex : data )
        {
            values->QueueUpdate( localBoundaryOffset + i, 0, std::get<1>( vertex ) );
            values->QueueUpdate( localBoundaryOffset + i, 1, std::get<2>( vertex ) );

            if ( mesh().nGeometricD() == 3 )
                values->QueueUpdate( localBoundaryOffset + i, 2, std::get<3>( vertex ) );

            i++;
        }
    }

    std::unique_ptr<El::DistMatrix<double> > result = rbf->interpolate( values );

    int nbInterpolationPoints = 0;

    forAll( mesh().points(), i )
    {
        if ( twoDCorrector.marker()[i] == 0 )
            nbInterpolationPoints++;
    }

    std::vector<int> allInterpolationPoints = mxx::allgather( nbInterpolationPoints );

    vectorField valuesInterpolationField( mesh().points().size(), Foam::vector::zero );

    std::vector<double> buffer;
    result->ReservePulls( nbInterpolationPoints * mesh().nGeometricD() );

    size_t localOffset = 0;

    for ( int i = 0; i < Pstream::myProcNo(); i++ )
        localOffset += allInterpolationPoints[i];

    for ( int i = 0; i < nbInterpolationPoints; i++ )
    {
        for ( int j = 0; j < mesh().nGeometricD(); j++ )
            result->QueuePull( localOffset + i, j );
    }

    result->ProcessPullQueue( buffer );

    int index = 0;

    forAll( valuesInterpolationField, i )
    {
        if ( twoDCorrector.marker()[i] != 0 )
            continue;

        for ( int j = 0; j < mesh().nGeometricD(); j++ )
        {
            valuesInterpolationField[i][j] = buffer[index];
            index++;
        }
    }

    twoDCorrector.setShadowSide( valuesInterpolationField );

    assert( newPoints.size() == valuesInterpolationField.size() );

    newPoints = valuesInterpolationField;
}
